---
author: "Joe Colgan"
title: "**Weight gene co-expression network analysis of fat bodies of control and inseminated _Bombus terrestris_ workers and queens**"
output:
  pdf_document: default
  html_document: default
fig_width: 4
fig_height: 4
fontsize: 20pt
---

Load libraries:

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
#install.packages("BiocManager") 
#BiocManager::install("WGCNA") 
# Load libraries; install from scratch if needed
libraries <- c("readr",
               "DESeq2",
               "ggplot2",
               "ggpubr",
               "purrr",
               "UpSetR",
               "hash",
               "reshape2",
               "eulerr",
               "knitr",
               "RUVSeq",
               "PoiClaClu",
               "genefilter",
               "pheatmap",
               "RColorBrewer",
               "WGCNA")
for (lib in libraries) {
    if (require(package = lib, character.only = TRUE)) {
        print("Successful")
    } else {
        print("Installing")
        source("https://bioconductor.org/biocLite.R")
        library(lib, character.only = TRUE )
    }
}
dir.create("results")
opts_chunk$set(fig.width = 12, fig.height = 8)
```

Load input data:  

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
# The following setting is important, do not omit.
options(stringsAsFactors = FALSE)

## Load experimental data:
data <- readRDS(file = "input/vsd_fatbody_treatment.rds")
data_counts <- assay(data)
```

In addition to expression data, the data files contain extra information about the surveyed probes we do not need. One can inspect larger data frames such as femData by invoking R data editor via fix(femData). The expression data set contains 135 samples. Note that each row corresponds to a gene and column to a sample or auxiliary information. We now remove the auxiliary data and transpose the expression data for further analysis.

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## We need a transposed dataframe consisting of gene per column and sample per row:
transposed_data <- t(data_counts)
```

1.b Checking data for excessive missing values and identification of outlier microarray samples

We first check for genes and samples with too many missing values:

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Run for experimental dataset:
transposed_gsg <- goodSamplesGenes(transposed_data, verbose = 3)
transposed_gsg$allOK
```

If the last statement returns TRUE, all genes have passed the cuts. If not, we remove the offending genes and samples from the data:

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Run for experimental:
if (!transposed_gsg$allOK)
{
  # Optionally, print the gene and sample names that were removed:
  if (sum(!transposed_gsg$goodGenes)>0)
     printFlush(paste("Removing genes:", paste(names(transposed_data)[!transposed_gsg$goodGenes], collapse = ", ")));
  if (sum(!transposed_gsg$goodSamples)>0)
     printFlush(paste("Removing samples:", paste(rownames(transposed_data)[!transposed_gsg$goodSamples], collapse = ", ")));
  # Remove the offending genes and samples from the data:
  transposed_data = transposed_data[transposed_gsg$goodSamples, transposed_gsg$goodGenes]
}
```

Next we cluster the samples (in contrast to clustering genes that will come later) to see if there are any obvious outliers.

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## RUn for experimental samples:
exp_sampleTree = hclust(dist(transposed_data), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(exp_sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
    cex.axis = 1.5, cex.main = 2)
```

It appears there is one outlier (sample F2_221, see Fig. 1). One can remove it by hand, or use an automatic approach. Choose a height cut that will remove the offending sample, say 15 (the red line in the plot), and use a branch cut at that height.

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
# Plot a line to show the cut
#abline(h = 15, col = "red");
# Determine cluster under the line
clust = cutreeStatic(exp_sampleTree,
                     cutHeight = 120,
                     minSize = 10)
table(clust)
# clust 1 contains the samples we want to keep.
keepSamples = (clust==1)
transposed_data_filt = transposed_data[keepSamples, ]
nGenes = ncol(transposed_data_filt)
nSamples = nrow(transposed_data_filt)
```

The variable datExpr now contains the expression data ready for network analysis.  

1.c Loading clinical trait data
We now read in the trait data and match the samples for which they were measured to the expression samples.

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Read in sample information:
samples_information <- read.table(file = "data/sample_info_fat_body.txt",
                                  header = FALSE)
## Remove tissue:
samples_information$V3 <- NULL
row.names(samples_information) <- samples_information$V1
samples_information$V1 <- NULL
## Update column names:
colnames(samples_information) <- c("caste",
                                   "stage",
                                   "treatment")
## Remove outliers:
samples_information <- samples_information[keepSamples, ]
```

We now have the expression data in the variable datExpr, and the corresponding clinical traits in the variable datTraits. Before we continue with network construction and module detection, we visualize how the clinical traits relate to the sample dendrogram.  

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Run for experimental dataset:
# Re-cluster samples
exp_sampleTree2 = hclust(dist(transposed_data_filt),
                         method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
exp_traitColors = numbers2colors(samples_information, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(exp_sampleTree2,
                    exp_traitColors,
                  groupLabels = names(samples_information),
                  main = "Sample dendrogram and trait heatmap")

saveRDS(object = exp_sampleTree2, file = "results/exp_sampleTree2_fatbody.rds")
saveRDS(object = exp_traitColors, file = "results/exp_traitColors_fatbody.rds")
```

In the plot, shown in Fig. 2, white means a low value, red a high value, and grey a missing entry. The last step is to save the relevant expression and trait data for use in the next steps of the tutorial.  

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
save(transposed_data_filt,
     samples_information,
     file = "results/fatbody-01-dataInput.RData")
```

2.b Step-by-step network construction and module detection
2.b.1 Choosing the soft-thresholding power: analysis of network topology
Constructing a weighted gene network entails the choice of the soft thresholding power β to which co-expression similarity is raised to calculate adjacency [1]. The authors of [1] have proposed to choose the soft thresholding power based on the criterion of approximate scale-free topology. We refer the reader to that work for more details; here we illustrate the use of the function pickSoftThreshold that performs the analysis of network topology and aids the user in choosing a proper soft-thresholding power. The user chooses a set of candidate powers (the function provides suitable default values), and the function returns a set of network indices that should be inspected, for example as follows:  

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## For the experimental set:
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=40, by=2))
# Call the network topology analysis function
exp_sft = pickSoftThreshold(transposed_data_filt, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(exp_sft$fitIndices[,1], -sign(exp_sft$fitIndices[,3])*exp_sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(exp_sft$fitIndices[,1], -sign(exp_sft$fitIndices[,3])*exp_sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(exp_sft$fitIndices[,1], exp_sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(exp_sft$fitIndices[,1], exp_sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

2.b.2 Co-expression similarity and adjacency
We now calculate the adjacencies, using the soft thresholding power 7:

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## For experimental dataset:
softPower = 14;
exp_adjacency = adjacency(transposed_data_filt, power = softPower);
```

2.b.3 Topological Overlap Matrix (TOM)
To minimize effects of noise and spurious associations, we transform the adjacency into Topological Overlap Matrix, and calculate the corresponding dissimilarity:

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Experimental dataset:
# Turn adjacency into topological overlap
exp_TOM = TOMsimilarity(exp_adjacency);
diss_exp_TOM = 1-exp_TOM
```

2.b.4 Clustering using TOM
We now use hierarchical clustering to produce a hierarchical clustering tree (dendrogram) of genes. Note that we use the function hclust that provides a much faster hierarchical clustering routine than the standard hclust function.  

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Experimental data:
exp_geneTree = hclust(as.dist(diss_exp_TOM), method = "average");
# Plot the resulting clustering tree (dendrogram)
sizeGrWindow(12,9)
plot(exp_geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
    labels = FALSE, hang = 0.04);
```

The clustering dendrogram plotted by the last command is shown in Figure 2. In the clustering tree (dendrogram), each leaf, that is a short vertical line, corresponds to a gene. Branches of the dendrogram group together densely interconnected, highly co-expressed genes. Module identification amounts to the identification of individual branches (”cutting the branches off the dendrogram”). There are several methods for branch cutting; our standard method is the Dynamic Tree Cut from the package dynamicTreeCut. The next snippet of code illustrates its use.  

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Experimental set:
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 30;
# Module identification using dynamic tree cut:
exp_dynamicMods = cutreeDynamic(dendro = exp_geneTree, distM = diss_exp_TOM,
              deepSplit = 2, pamRespectsDendro = FALSE,
              minClusterSize = minModuleSize);
table(exp_dynamicMods)
```

The function returned 22 modules labeled 1–22 largest to smallest. Label 0 is reserved for unassigned genes. The above command lists the sizes of the modules. We now plot the module assignment under the gene dendrogram:

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Experimental data:
# Convert numeric lables into colors
exp_dynamicColors = labels2colors(exp_dynamicMods)
table(exp_dynamicColors)
# Plot the dendrogram and colors underneath
sizeGrWindow(8,6)
plotDendroAndColors(exp_geneTree, exp_dynamicColors, "Dynamic Tree Cut",
                  dendroLabels = FALSE, hang = 0.03,
                  addGuide = TRUE, guideHang = 0.05,
                  main = "Gene dendrogram and module colors")
```

2.b.5 Merging of modules whose expression profiles are very similar
The Dynamic Tree Cut may identify modules whose expression profiles are very similar. It may be prudent to merge such modules since their genes are highly co-expressed. To quantify co-expression similarity of entire modules, we calculate their eigengenes and cluster them on their correlation  

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Experimental dataset:
# Calculate eigengenes
exp_MEList = moduleEigengenes(transposed_data_filt, colors = exp_dynamicColors)
exp_MEs = exp_MEList$eigengenes
# Calculate dissimilarity of module eigengenes
exp_MEDiss = 1-cor(exp_MEs);
# Cluster module eigengenes
exp_METree = hclust(as.dist(exp_MEDiss), method = "average");
# Plot the result
sizeGrWindow(7, 6)
plot(exp_METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")
```

We choose a height cut of 0.25, corresponding to correlation of 0.75, to merge (see Fig. 4):

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## for the experimental dataset:
exp_MEDissThres = 0.25
# Plot the cut line into the dendrogram
# abline(h=exp_MEDissThres, col = "red")
# Call an automatic merging function
exp_merge = mergeCloseModules(transposed_data_filt,
                              exp_dynamicColors,
                              cutHeight = exp_MEDissThres,
                              verbose = 3)
# The merged module colors
exp_mergedColors = exp_merge$colors;
# Eigengenes of the new merged modules:
exp_mergedMEs = exp_merge$newMEs;
```

To see what the merging did to our module colors, we plot the gene dendrogram again, with the original and merged module colors underneath (Figure 5).

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
sizeGrWindow(12, 9)
#pdf(file = "Plots/geneDendro-3.pdf", wi = 9, he = 6)
plotDendroAndColors(exp_geneTree, cbind(exp_dynamicColors,
                                        exp_mergedColors),
                  c("Dynamic Tree Cut", "Merged dynamic"),
                  dendroLabels = FALSE, hang = 0.03,
                  addGuide = TRUE, guideHang = 0.05)
```

In the subsequent analysis, we will use the merged module colors in mergedColors. We save the relevant variables for use in subsequent parts of the tutorial:

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Experimental dataset:
# Rename to moduleColors
exp_moduleColors = exp_mergedColors
# Construct numerical labels corresponding to the colors
exp_colorOrder = c("grey", standardColors(50));
exp_moduleLabels = match(exp_moduleColors, exp_colorOrder)-1;
exp_MEs = exp_mergedMEs;
# Save module colors and labels for use in subsequent parts
save(exp_MEs,
     exp_moduleLabels,
     exp_moduleColors,
     exp_geneTree,
     file = "results/fatbody-02-networkConstruction-stepByStep.RData")
```

3 Relating modules to external clinical traits 3.a Quantifying module–trait associations
In this analysis we would like to identify modules that are significantly associated with the measured clinical traits. Since we already have a summary profile (eigengene) for each module, we simply correlate eigengenes with external traits and look for the most significant associations:

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
# Define numbers of genes and samples
exp_nGenes = ncol(transposed_data_filt);
exp_nSamples = nrow(transposed_data_filt);
# Recalculate MEs with color labels
exp_MEs0 = moduleEigengenes(transposed_data_filt, exp_moduleColors)$eigengenes
exp_MEs = orderMEs(exp_MEs0)
exp_moduleTraitCor = cor(exp_MEs, samples_information, use = "p");
exp_moduleTraitPvalue = corPvalueStudent(exp_moduleTraitCor, exp_nSamples);
```

Since we have a moderately large number of modules and traits, a suitable graphical representation will help in reading the table. We color code each association by the correlation value:  

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
## Experimental dataset:
sizeGrWindow(10,6)
# Will display correlations and their p-values
exp_textMatrix = paste(signif(exp_moduleTraitCor, 2), "\n(",
                        signif(exp_moduleTraitPvalue, 1), ")", sep = "");
dim(exp_textMatrix) = dim(exp_moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = exp_moduleTraitCor,
             xLabels = names(samples_information),
             yLabels = names(exp_MEs),
             ySymbols = names(exp_MEs),
             colorLabels = FALSE,
             colors = blueWhiteRed(50),
             textMatrix = exp_textMatrix,
             setStdMargins = FALSE,
             cex.text = 0.5,
             zlim = c(-1,1),
             main = paste("Module-trait relationships"))

# Save module colors and labels for use in subsequent parts
save(exp_MEs,
     exp_moduleTraitCor,
     samples_information,
     exp_textMatrix,
     file = "results/fatbody-03-input_for_labelled_heatmap.RData")
```

The resulting color-coded table is shown in Fig. 1.
The analysis identifies the several significant module–trait associations. We will concentrate on weight as the trait of interest.  

3.b Gene relationship to trait and important modules: Gene Significance and Module Membership
We quantify associations of individual genes with our trait of interest (weight) by defining Gene Significance GS as (the absolute value of) the correlation between the gene and the trait. For each module, we also define a quantitative measure of module membership MM as the correlation of the module eigengene and the gene expression profile. This allows us to quantify the similarity of all genes on the array to every module.

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
# Define variable treatment containing the treatment column of samples information
treatment = as.data.frame(samples_information$treatment);
names(treatment) = "treatment"
# names (colors) of the modules
exp_modNames = substring(names(exp_MEs), 3)
exp_geneModuleMembership = as.data.frame(cor(transposed_data_filt,
                                         exp_MEs,
                                         use = "p"));
exp_MMPvalue = as.data.frame(corPvalueStudent(as.matrix(exp_geneModuleMembership),
                                          exp_nSamples));

names(exp_geneModuleMembership) = paste("MM", exp_modNames, sep="");
names(exp_MMPvalue) = paste("p.MM", exp_modNames, sep="");
exp_geneTraitSignificance = as.data.frame(cor(transposed_data_filt,
                                          treatment,
                                          use = "p"));
exp_GSPvalue = as.data.frame(corPvalueStudent(as.matrix(exp_geneTraitSignificance),
                                          exp_nSamples));
names(exp_geneTraitSignificance) = paste("GS.", names(treatment), sep="");
names(exp_GSPvalue) = paste("p.GS.", names(treatment), sep="")
```

3.c Intramodular analysis: identifying genes with high GS and MM
Using the GS and MM measures, we can identify genes that have a high significance for weight as well as high module membership in interesting modules. As an example, we look at the brown module that has the highest association with weight. We plot a scatterplot of Gene Significance vs. Module Membership in the brown module:  

```{r, echo = FALSE, message = FALSE, results = 'hide', warning=FALSE}
exp_module = "orange"
exp_column = match(exp_module, exp_modNames);
exp_moduleGenes = exp_moduleColors==exp_module;
sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(exp_geneModuleMembership[exp_moduleGenes, exp_column]),
                   abs(exp_geneTraitSignificance[exp_moduleGenes, 1]),
                 xlab = paste("Module Membership in", exp_module, "module"),
                 ylab = "Gene significance for treatment",
                 main = paste("Module membership vs. gene significance\n"),
                 cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = exp_module)

# Save module colors and labels for use in subsequent parts
save(exp_geneModuleMembership,
     exp_moduleGenes,
     exp_module,
     exp_column,
     exp_geneTraitSignificance,
     file = "results/fatbody-04-input_for_membership_scatterplot_purple.RData")
```